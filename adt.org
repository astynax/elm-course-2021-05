* Алгебраические Типы Данных в Elm
** Типы-произведения
Типы-произведения являются составными типами, значения которых содержат (агрегируют) /одновременно/ несколько вложенных значений.

В язык встроены два вида типов-произведений:

1. кортежи (tuples)
2. записи (records)

И то, и другое произведения описываются перечислением типов содержимого. Подходящим под такие составные типы будет такое значение, которое содержит требуемые значения-компоненты.

*** Кортежи
#+BEGIN_SRC elm
triple : (Int, String, Bool)
triple = (42, "Hello", True)  -- порядок важен!
#+END_SRC

Значения, составляющие кортеж, называют /элементами кортежа/, а соответствующие им части типа кортежа — /типами элементов/.
*** Записи
#+BEGIN_SRC elm
user : { name : String, active : Bool }
user = { active = True, name = "admin"}  -- порядок не важен!
#+END_SRC

~name~ и ~active~ называются /именованными полями (fields) записи/, а ~name : String~ — /тип поля/.

Часто такие записи, описываемые только лишь перечислением полей, называют /анонимными записями/.
** Типы-суммы
Любой типы-сумма описывается набором меток. Метки, так же называемые /конструкторами значений/, соотносятся друг с другом операцией "ИЛИ", то есть любое значение описываемого типа-суммы будет иметь /строго одну метку/. В рамках одного пространства имён (модуля) два типа-суммы не могут иметь одинаковые метки, то есть метка однозначно связана с соответствующей суммой.

Примеры простых типов-сумм:

#+BEGIN_SRC elm
type Flag = On | Off
type Shape = Circle | Rectangle | Square
type Unit = Unit  -- ровно один конструктор!
#+END_SRC

Заметьте, что ~Unit~ здесь фигурирует и как имя типа, и как метка. Дело в том, что имена типов и имена конструкторов живут /в разных пространствах имён/.
** Суммы произведений
Каждый конструктор, уже будучи членом некоторой суммы, может, в свою очередь, быть /произведением/ других типов, то есть может содержать одно или несколько позиционных /полей/:

#+BEGIN_SRC elm
type Point = Point Int Int
type Line = Line Point Point
type PolyLine
    = End Point
    | Segment Point PolyLine  -- рекурсивный тип
#+END_SRC

Ещё раз подчеркну, что имена типов и имена конструкторов не смешиваются, поэтому такой тип абсолютно легален:

#+BEGIN_SRC elm
type IntOrString
    = Int Int
    | String String
--    ^метка ^тип
#+END_SRC
** Именованные записи
Если описать тип-сумму с одной меткой и одним полем, представляющим собой анонимную запись, мы получим /именованную запись/:

#+BEGIN_SRC elm
type Person = Person
    { firstName : String
    , lastName : String
    , age : Int
    }
#+END_SRC
** Редкости
Lego, описанный выше, позволяет делать многое. Но разные конструкции по-разному полезны. Опишу несколько осуществимых, но не очень полезных образчиков.
*** "Перерекорды"
#+BEGIN_SRC elm
type T = T { a : Int } { b : String }
#+END_SRC
*** "Метка плюс кортеж"
#+BEGIN_SRC elm
type RGB = RGB (Int, Int, Int)  -- это просто избыточно
#+END_SRC
